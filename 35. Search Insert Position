# Question:

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4


# Solutio 1: Complexity - O(n) non optimized

class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        
        for i in range(len(nums)):
            if target <= nums[i]:
                return i

        return len(nums)

# Logic

- We have to find the position of the item either matching or is > target, since we would want :
- either the position of exact matching element
- OR the first item which is just greater than the target, we would place the target in the position of that element as per ordered list.

# Exception / Edge cases

- edge case handled when target is > than all elements, our loop will end and return null, thus we have to add handling for such cases, 
- the output should the the last position which is the length of the array / list


# Solution 2 - Complexity : O(log n) Optimized using Binary Search

class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        
        left = 0
        right = len(nums) - 1

        while left <= right :

            mid = left + (right - left) // 2

            if nums[mid] == target :
                return mid
            elif nums[mid] < target :
                left = mid + 1
            else :
                right = mid - 1
        
        return left

Logic:

- We have to check the target, and to refine our apprach, we can look at the problem using binary search
- we start with 1st and last index
- we then calculate middle index, and we use left + (right - left) // 2 apprach since we want middle that is between every left and right
- example if left = 0, right = 9, then mid = 4..... in the next loop lets say we hit elif condition so left bcomes 5, 
- to calculate mid we cannot do 9 - 5 / 2 which will give 2 i.e. incorrect
- our mid apprach will give mid between every new left right pair, by adding left we ensure this happens
- now if we exit the while loop , it means left has gone ahead of right
- and in this condition we will need to insert at left position
